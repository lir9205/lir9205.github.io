{"meta":{"title":"李芮","subtitle":null,"description":null,"author":"qingtian","url":"https://lir9205.github.io","root":"/"},"pages":[],"posts":[{"title":"uni-app学习笔记","slug":"uni-app学习笔记","date":"2019-07-16T01:21:39.000Z","updated":"2019-07-17T09:41:10.000Z","comments":false,"path":"2019/07/16/uni-app学习笔记/","link":"","permalink":"https://lir9205.github.io/2019/07/16/uni-app学习笔记/","excerpt":"","text":"tips1. 禁止蒙版下的页面滚动 若需要禁止蒙版下的页面滚动，可使用 @touchmove.stop.prevent=&quot;moveHandle&quot;，moveHandle 可以用来处理 touchmove 的事件，也可以是一个空函数。 1&lt;view class=&quot;mask&quot; @touchmove.stop.prevent=&quot;moveHandle&quot;&gt;&lt;/view&gt; 2. 注册全局组件uni-app 支持配置全局组件，需在 main.js 里进行全局注册，注册后就可在所有页面里使用该组件。 注意：Vue.component 的第一个参数必须是静态的字符串。 示例： 123import Vue from &apos;vue&apos;import pageHead from &apos;./components/page-head.vue&apos;Vue.component(&apos;page-head&apos;,pageHead) index.vue 里可以直接使用组件 12345&lt;template&gt; &lt;view&gt; &lt;page-head&gt;&lt;/page-head&gt; &lt;/view&gt;&lt;/template&gt; 3. 如何获取上个页面传递的数据在 onLoad 里得到，onLoad 的参数是其他页面打开当前页面所传递的数据。 4. 如何设置全局的数据和全局的方法uni-app 内置了 vuex ，在app里的使用，可参考hello-uniapp store/index.js 1234567891011121314151617181920212223//store.jsimport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123;...&#125;, mutations: &#123;...&#125;, actions: &#123;...&#125;&#125;)export default store//main.js...import store from &apos;./store&apos;Vue.prototype.$store = storeconst app = new Vue(&#123; store,...&#125;)...//test.vue 使用时：import &#123;mapState,mapMutations&#125; from &apos;vuex&apos; 5. 组件属性设置不生效解决办法当重复设置某些属性为相同的值时，不会同步到view层。 例如：每次将scroll-view组件的scroll-top属性值设置为0，只有第一次能顺利返回顶部。 这和props的单向数据流特性有关，组件内部scroll-top的实际值改动后，其绑定的属性并不会一同变化。 解决办法有两种（以scroll-view组件为例）： 监听scroll事件，记录组件内部变化的值，在设置新值之前先设置为记录的当前值 1&lt;scroll-view :scroll-top=&quot;scrollTop&quot; scroll-y=&quot;true&quot; @scroll=&quot;scroll&quot;&gt; 123456789101112131415161718192021export default &#123; data() &#123; return &#123; scrollTop: 0, old: &#123; scrollTop: 0 &#125; &#125; &#125;, methods: &#123; scroll: function(e) &#123; this.old.scrollTop = e.detail.scrollTop &#125;, goTop: function(e) &#123; this.scrollTop = this.old.scrollTop this.$nextTick(function() &#123; this.scrollTop = 0 &#125;); &#125; &#125;&#125; 监听scroll事件，获取组件内部变化的值，实时更新其绑定值 1&lt;scroll-view :scroll-top=&quot;scrollTop&quot; scroll-y=&quot;true&quot; @scroll=&quot;scroll&quot;&gt; 123456789101112131415export default &#123; data() &#123; return &#123; scrollTop: 0, &#125; &#125;, methods: &#123; scroll: function(e) &#123; this.scrollTop = e.detail.scrollTop &#125;, goTop: function(e) &#123; this.scrollTop = 0 &#125; &#125;&#125; 第二种解决方式在某些组件可能造成抖动，推荐第一种解决方式。 6. 运行环境判断12345if (process.env.NODE_ENV === &apos;development&apos;) &#123; console.log(&apos;开发环境&apos;) &#125; else &#123; console.log(&apos;生产环境&apos;) &#125; 7. 运行平台判断平台判断有2种场景，一种是在编译期判断，一种是在运行期判断。 7.1 编译期判断编译期判断，即条件编译，不同平台在编译出包后已经是不同的代码。 12345// #ifdef H5 alert(&apos;只有h5平台才有alert方法&apos;);// #endif // 如上代码只会编译到H5的发行包里，其他平台的包不会包含如上代码。 7.2 运行期判断运行期判断是指代码已经打入包中，仍然需要在运行期判断平台，此时可使用 uni.getSystemInfoSync().platform 判断客户端环境是 Android、iOS 还是小程序开发工具（在百度小程序开发工具、微信小程序开发工具、支付宝小程序开发工具中使用 uni.getSystemInfoSync().platform 返回值均为 devtools） 1234567891011switch (uni.getSystemInfoSync().platform) &#123; case &apos;android&apos;: console.log(&apos;运行在Android上&apos;); break; case &apos;ios&apos;: console.log(&apos;运行在iOS上&apos;); break; default: //&apos;devtools&apos; console.log(&apos;运行在开发者工具上&apos;); break;&#125;","categories":[{"name":"uni-app","slug":"uni-app","permalink":"https://lir9205.github.io/categories/uni-app/"}],"tags":[{"name":"vue 小程序 uni-app","slug":"vue-小程序-uni-app","permalink":"https://lir9205.github.io/tags/vue-小程序-uni-app/"}]},{"title":"小程序初学笔记","slug":"小程序初学笔记","date":"2019-07-02T05:34:44.000Z","updated":"2019-07-13T10:02:16.000Z","comments":false,"path":"2019/07/02/小程序初学笔记/","link":"","permalink":"https://lir9205.github.io/2019/07/02/小程序初学笔记/","excerpt":"","text":"#geoJSON 获取地址 地图选择器 geojson.io 可以通过绘制范围生成geojson数据 shp文件在线转geojson #博客 基于hexo+github搭建一个独立博客https://www.cnblogs.com/MuYunyun/p/5927491.html","categories":[],"tags":[]},{"title":"前端tips","slug":"前端tips","date":"2019-06-14T07:37:01.000Z","updated":"2019-07-23T08:47:55.000Z","comments":false,"path":"2019/06/14/前端tips/","link":"","permalink":"https://lir9205.github.io/2019/06/14/前端tips/","excerpt":"","text":"jquery控制input只能输入数字和两位小数1234567function num(obj)&#123; obj.value = obj.value.replace(/[^\\d.]/g,&quot;&quot;); //清除&quot;数字&quot;和&quot;.&quot;以外的字符 obj.value = obj.value.replace(/^\\./g,&quot;&quot;); //验证第一个字符是数字 obj.value = obj.value.replace(/\\.&#123;2,&#125;/g,&quot;.&quot;); //只保留第一个, 清除多余的 obj.value = obj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;); obj.value = obj.value.replace(/^(\\-)*(\\d+)\\.(\\d\\d).*$/,&apos;$1$2.$3&apos;); //只能输入两个小数&#125; 限制只能保留两位小数点 1&lt;input type=&quot;text&quot; onkeyup=&quot;num(this)&quot; size=&quot;10&quot;/&gt;元 限制只能输入数字 1&lt;input type=&quot;text&quot; onkeyup=&apos;this.value=this.value.replace(/\\D/gi,&quot;&quot;)&apos;/&gt; 限制只能输入数字、字母和”-“ 1&lt;input type=&quot;text&quot; onkeyup=&apos;value=value.replace(/[^A-Za-z0-9\\-]+/g,&quot;&quot;)&apos;/&gt; 完美解决 ios10 及以上 Safari 无法禁止缩放的问题移动端web缩放有两种： 双击缩放 双指手势缩放 在 iOS 10之前，iOS 和 Android 都可以通过一行 meta 标签来禁止页面缩放： 1&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;&quot; name=&quot;viewport&quot; /&gt; 但 iOS 10开始，meta 设置在 Safari 内无效了。 在网上看到一个解决方案： 123456789101112131415window.οnlοad=function () &#123; document.addEventListener(&apos;touchstart&apos;,function (event) &#123; if(event.touches.length&gt;1)&#123; event.preventDefault(); &#125; &#125;) var lastTouchEnd=0; document.addEventListener(&apos;touchend&apos;,function (event) &#123; var now=(new Date()).getTime(); if(now-lastTouchEnd&lt;=300)&#123; event.preventDefault(); &#125; lastTouchEnd=now; &#125;,false)&#125; 经过测试，这种方法只能禁止双击缩放。只好继续找解决方案了。 原来在 iOS 里有一组双指手势操作的事件：gesturestart、gesturechange、gestureend在上面的 js 方法里加入下面的事件监听： 123document.addEventListener(&apos;gesturestart&apos;, function (event) &#123; event.preventDefault();&#125;); 既不能双击缩放，也不能双指缩放。 完整代码123456789101112131415161718192021window.onload = function() &#123; // 阻止双击放大 var lastTouchEnd = 0; document.addEventListener(&apos;touchstart&apos;, function(event) &#123; if (event.touches.length &gt; 1) &#123; event.preventDefault(); &#125; &#125;); document.addEventListener(&apos;touchend&apos;, function(event) &#123; var now = (new Date()).getTime(); if (now - lastTouchEnd &lt;= 300) &#123; event.preventDefault(); &#125; lastTouchEnd = now; &#125;, false); // 阻止双指放大 document.addEventListener(&apos;gesturestart&apos;, function(event) &#123; event.preventDefault(); &#125;);&#125;","categories":[],"tags":[]},{"title":"vim","slug":"vim","date":"2019-06-14T07:12:36.000Z","updated":"2019-07-02T01:31:54.000Z","comments":false,"path":"2019/06/14/vim/","link":"","permalink":"https://lir9205.github.io/2019/06/14/vim/","excerpt":"","text":"基于hexo+github搭建一个独立博客 vim退出命令注意：这些命令前面都有一个冒号： 当编辑完文档，准备退出Vi返回到shell时，能够使用以下几种方法之一。 在命令模式中:ZZ1:ZZ 连按两次大写字母Z，若当前编辑的文档曾被修改过，则Vi保存该文档后退出，返回到shell；若当前编辑的文档没被修改过，则Vi直接退出, 返回到shell。 在末行模式下:w1:w Vi保存当前编辑文档，但并不退出，而是继续等待用户输入命令。在使用w命令时，能够再给编辑文档起一个新的文档名。 1:w newfile 此时Vi将把当前文档的内容保存到指定的newfile中，而原有文档保持不变。若newfile是个已存在的文档，则Vi在显示窗口的状态行给出提示信息： File exists （use ! to override）此时，若用户真的希望用文档的当前内容替换newfile中原有内容，可使用命令 1:w! newfile 否则可选择另外的文档名来保存当前文档。 :q1:q 系统退出Vi返回到shell。若在用此命令退出Vi时，编辑文档没有被保存，则Vi在显示窗口的最末行显示如下信息： No write since last change （use ! to overrides） 提示用户该文档被修改后没有保存，然后Vi并不退出，继续等待用户命令。若用户就是不想保存被修改后的文档而要强行退出Vi时，可使用命令 1:q! Vi放弃所作修改而直接退到shell下。 :wq1:wq Vi将先保存文档，然后退出Vi返回到shell。 :x1:x 该命令的功能同命令模式下的ZZ命令功能相同。","categories":[],"tags":[]},{"title":"gulp4.0+ 执行 gulp 命令报错记录","slug":"gulp相关","date":"2019-06-12T09:05:01.000Z","updated":"2019-07-02T01:31:54.000Z","comments":true,"path":"2019/06/12/gulp相关/","link":"","permalink":"https://lir9205.github.io/2019/06/12/gulp相关/","excerpt":"","text":"1. Task function must be specified在执行 $ gulp 命令时控制台报错： Task function must be specified解决方法： 使用$ gulp -v 查看 gulp 的 Local version 版本和 package.json 里面的版本是否相同 123$ gulp -vCLI version: 2.2.0Local version: 4.0.2 package.json： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"3.8.0\" &#125;, \"dependencies\": &#123; \"ejs\": \"^2.6.1\", \"hexo\": \"^3.8.0\", \"hexo-abbrlink\": \"^2.0.5\", \"hexo-deployer-git\": \"^1.0.0\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-feed\": \"^1.2.2\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-json-content\": \"^4.1.3\", \"hexo-generator-sitemap\": \"^1.2.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-marked\": \"^1.0.1\", \"hexo-server\": \"^0.3.3\" &#125;, \"devDependencies\": &#123; \"gulp\": \"^4.0.2\", \"gulp-autoprefixer\": \"^6.1.0\", \"gulp-htmlclean\": \"^2.7.22\", \"gulp-htmlmin\": \"^5.0.1\", \"gulp-jshint\": \"^2.1.0\", \"gulp-less\": \"^4.0.1\", \"gulp-minify-css\": \"^1.2.4\", \"gulp-notify\": \"^3.2.0\", \"gulp-path\": \"^4.0.0\", \"gulp-plumber\": \"^1.2.1\", \"gulp-rename\": \"^1.4.0\", \"gulp-rev-append\": \"^0.1.8\", \"gulp-sequence\": \"^1.0.0\", \"gulp-uglify\": \"^3.0.2\", \"gulp-watch\": \"^5.0.1\", \"jshint\": \"^2.10.2\", \"jshint-stylish\": \"^2.2.1\" &#125;&#125; gulp 3 和 gulp 4 运行方式是不一样的，所以会出现错误。gulp 3，如果有一个任务A，B和C的列表，你想在一个序列中运行（确保A在B开始之前完成，而B在C开始之前完成），代码如下： 123456789gulp.task('a', function () &#123; // Do something.&#125;);gulp.task('b', ['a'], function () &#123; // Do some stuff.&#125;);gulp.task('c', ['b'], function () &#123; // Do some more stuff.&#125;); gulp 4最大的变化就是你不能像以前那样传递一个依赖任务列表。否则会得到以下错误： 123456789101112131415assert.js:42 throw new errors.AssertionError(&#123; ^AssertionError [ERR_ASSERTION]: Task function must be specified at Gulp.set [as _setTask] (/Users/yscredit/Desktop/myBlog/node_modules/_undertaker@1.2.1@undertaker/lib/set-task.js:10:3) at Gulp.task (/Users/yscredit/Desktop/myBlog/node_modules/_undertaker@1.2.1@undertaker/lib/task.js:13:8) at Object.&lt;anonymous&gt; (/Users/yscredit/Desktop/myBlog/themes/hexo-theme-snippet/gulpfile.js:105:10) at Module._compile (module.js:652:30) at Object.Module._extensions..js (module.js:663:10) at Module.load (module.js:565:32) at tryModuleLoad (module.js:505:12) at Function.Module._load (module.js:497:3) at Module.require (module.js:596:17) at require (internal/module.js:11:18) 你需要使用 gulp.series 和 gulp.parallel，因为 gulp 任务现在只有两个参数。 gulp.series：按照顺序执行 gulp.paralle：可以并行计算123456789101112gulp.task('my-tasks', gulp.series('a', 'b', 'c', function() &#123; // Do something after a, b, and c are finished.&#125;));gulp.task('build', gulp.parallel('styles', 'scripts', 'images', function () &#123; // Build the website.&#125;));&lt;!-- 或者这样 --&gt;gulp.task('my-tasks', gulp.series('a', gulp.parallel('styles','scripts', 'images'), 'b', 'c', function() &#123; // Do something after a, b, and c are finished.&#125;)); 相关任务必须在被调用之前发生。 2. The following tasks did not complete: default,Did you forget to signal async completion?当 gulp 为如下代码的时候： 1234567// 以下代码会执行在node环境下const gulp = require( \"gulp\" );// 创建一个gulp的任务gulp.task( \"default\",function()&#123; console.log( \"gulp default task\" );&#125; ); 执行 $ gulp 打印： The following tasks did not complete: default, Did you forget to signal async completion? 使用 async 和 await 解决1234567// 以下代码会执行在node环境下const gulp = require( \"gulp\" );// 创建一个gulp的任务gulp.task( \"default\",async() =&gt; &#123; console.log( \"gulp default task\" );&#125; ); 官方解决办法在不使用文件流的情况下，向 task 的函数里传入一个名叫 done 的回调函数，以结束 task，如下代码所示: 12345678// 以下代码会执行在node环境下const gulp = require( \"gulp\" );// 创建一个gulp的任务gulp.task( \"default\",function(done)&#123; console.log( \"gulp default task\" ); done();&#125; ); done 回调函数的作用是在 task 完成时通知 gulp （而不是返回一个流），而 task 里的所有其他功能都纯粹依赖 Node 来实现。","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://lir9205.github.io/tags/gulp/"}]},{"title":"npm安装package.json中的模块依赖","slug":"postName","date":"2019-06-12T03:35:01.000Z","updated":"2019-07-02T01:31:54.000Z","comments":true,"path":"2019/06/12/postName/","link":"","permalink":"https://lir9205.github.io/2019/06/12/postName/","excerpt":"","text":"package有两种依赖 dependencies —— 运行依赖，依赖的项该是正常运行该包时所需要的依赖项 devDependencies —— 开发依赖，开发的时候需要的依赖项，像一些进行单元测试之类的包。 安装依赖命令npm一键安装package.json里的所有依赖文件 1$ npm install 只安装package.json里的dependencies（运行依赖）文件 1$ npm install --dependencies 只安装package.json里的devDependencies（开发依赖）文件 1$ npm install --devDependencies 更新依赖包到最新版本安装： 1$ sudo npm install -g npm-check-updates 使用：检查package.json中依赖包的最新版本，在package.json所在目录执行命令： 1$ ncu 更新依赖包到最新版本： 1$ ncu -u 更新全部依赖包到最新版本(包括当前指定版本范围满足最新版本号的,比如^4.2.0 -&gt; ^4.3.0)： 1$ ncu -a 最后再执行 1$ npm install","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://lir9205.github.io/tags/npm/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-12T02:49:40.000Z","updated":"2019-07-02T01:31:54.000Z","comments":true,"path":"2019/06/12/hello-world/","link":"","permalink":"https://lir9205.github.io/2019/06/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}